<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>KV Focus POC</title>
  <style>
    body { font: 14px system-ui, sans-serif; margin: 24px; max-width: 1200px; }
    .container { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; }
    @media (max-width: 900px) { .container { grid-template-columns: 1fr; } }
    
    #answer { border: 1px solid #ddd; padding: 12px; min-height: 140px; position: relative; }
    #answer h1, #answer h2, #answer h3, #answer h4, #answer h5, #answer h6 { margin-top: 0.5em; margin-bottom: 0.5em; }
    #answer p { margin: 0.5em 0; }
    #answer code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #answer pre { background: #f5f5f5; padding: 8px; border-radius: 4px; overflow-x: auto; }
    #answer pre code { background: none; padding: 0; }
    #answer ul, #answer ol { margin: 0.5em 0; padding-left: 1.5em; }
    #answer blockquote { border-left: 3px solid #ddd; padding-left: 1em; margin: 0.5em 0; color: #666; }
    
    .highlight { background: #fff3cd; padding: 2px 4px; border-radius: 3px; cursor: pointer; transition: background 0.2s; }
    .highlight:hover { background: #ffe69c; }
    .highlight.active { background: #ffc107; border: 2px solid #ff9800; }
    
    .saved-selections { margin-top: 16px; }
    .selection-item { border: 1px solid #ddd; border-radius: 4px; padding: 12px; margin: 8px 0; background: #f9f9f9; }
    .selection-item.active { border-color: #ff9800; background: #fff8e1; }
    .selection-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .selection-name { font-weight: bold; color: #333; }
    .selection-text { color: #666; font-size: 0.9em; margin: 4px 0; max-height: 60px; overflow: hidden; text-overflow: ellipsis; }
    .selection-actions { display: flex; gap: 8px; }
    .btn-small { padding: 4px 12px; font-size: 0.85em; cursor: pointer; border: 1px solid #ddd; background: white; border-radius: 3px; }
    .btn-small:hover { background: #f0f0f0; }
    .btn-small.chat { background: #2196f3; color: white; border-color: #2196f3; }
    .btn-small.chat:hover { background: #1976d2; border-color: #1976d2; }
    .btn-small.delete { border-color: #dc3545; color: #dc3545; }
    .btn-small.delete:hover { background: #dc3545; color: white; }
    
    .chat-section { border: 1px solid #ddd; border-radius: 4px; padding: 12px; margin-top: 16px; }
    .chat-messages { max-height: 400px; overflow-y: auto; margin-bottom: 12px; padding: 8px; background: #fafafa; border-radius: 3px; }
    .chat-message { margin: 8px 0; padding: 8px; border-radius: 4px; }
    .chat-message.user { background: #e3f2fd; text-align: right; }
    .chat-message.assistant { background: white; border: 1px solid #e0e0e0; }
    .chat-input-area { display: flex; gap: 8px; }
    .chat-input-area textarea { flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 3px; resize: vertical; }
    .chat-input-area button { padding: 8px 16px; cursor: pointer; background: #2196f3; color: white; border: none; border-radius: 3px; }
    .chat-input-area button:hover { background: #1976d2; }
    .chat-input-area button:disabled { background: #ccc; cursor: not-allowed; }
    
    #focused h1, #focused h2, #focused h3, #focused h4, #focused h5, #focused h6 { margin-top: 0.5em; margin-bottom: 0.5em; }
    #focused p { margin: 0.5em 0; }
    #focused code { background: #f5f5f5; padding: 2px 4px; border-radius: 3px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #focused pre { background: #f5f5f5; padding: 8px; border-radius: 4px; overflow-x: auto; }
    #focused pre code { background: none; padding: 0; }
    #focused ul, #focused ol { margin: 0.5em 0; padding-left: 1.5em; }
    #focused blockquote { border-left: 3px solid #ddd; padding-left: 1em; margin: 0.5em 0; color: #666; }
    
    .row { margin: 8px 0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 0.85em; color: #666; }
    button { padding: 8px 16px; cursor: pointer; background: #2196f3; color: white; border: none; border-radius: 3px; font-size: 14px; }
    button:hover { background: #1976d2; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    h3 { margin-top: 24px; margin-bottom: 12px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <h2>Track A â€” Fast Re-prefill Focus</h2>

  <div class="row">
    <textarea id="user" rows="3" style="width:100%" placeholder="Ask a general question..."></textarea>
  </div>
  <button id="ask">Ask</button>

  <div class="mono" id="status"></div>

  <div class="container">
    <div>
      <h3>Assistant answer (select text to save)</h3>
      <div id="answer" contenteditable="false"></div>
      
      <div style="margin-top: 12px;">
        <button id="saveSelection" disabled>Save Selected Text</button>
        <button id="clearHighlights" style="background: #666; margin-left: 8px;">Clear All Highlights</button>
      </div>

      <div class="saved-selections" id="savedSelections" style="display: none;">
        <h3>Saved Selections</h3>
        <div id="selectionsList"></div>
      </div>
    </div>

    <div>
      <div id="mainChatContainer" style="display: none;">
        <div class="chat-section">
          <h3>Continue Conversation</h3>
          <div style="margin-bottom: 8px; font-size: 0.9em; color: #666;">
            <strong>About the original answer</strong>
          </div>
          <div class="chat-messages" id="mainChatMessages"></div>
          <div class="chat-input-area">
            <textarea id="mainFollowup" rows="2" placeholder="Ask a follow-up question about the answer..."></textarea>
            <button id="sendMainFollowup">Send</button>
          </div>
        </div>
      </div>

      <div id="chatContainer" style="display: none;">
        <div class="chat-section">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 style="margin: 0;">Follow-up Conversation</h3>
            <button class="btn-small chat" onclick="showMainChat()" style="font-size: 0.85em;">Back to Main Chat</button>
          </div>
          <div style="margin-bottom: 8px; font-size: 0.9em; color: #666;">
            <strong>Selected:</strong> <span id="activeSelectionName">-</span>
          </div>
          <div class="chat-messages" id="chatMessages"></div>
          <div class="chat-input-area">
            <textarea id="followup" rows="2" placeholder="Ask a follow-up question about the selected text..."></textarea>
            <button id="sendFollowup">Send</button>
          </div>
        </div>
      </div>

      <div id="focusedContainer">
        <h3>Latest Response</h3>
        <div id="focused"></div>
      </div>
    </div>
  </div>

<script>
const API = "http://127.0.0.1:8000";
let lastMessageId = null; // Current message ID (may be from selections)
let originalMessageId = null; // Always tracks the original answer message ID
let rawAnswerText = ""; // Store raw markdown for selection
let savedSelections = []; // Array of {id, name, start, end, text, range}
let activeSelectionId = null;
let selectionCounter = 0;
let mainConversations = []; // Array of {question, answer, message_id} for original answer conversations

function sseFetch(url, body, onChunk, onDone) {
  fetch(url, { method: "POST", headers: {"Content-Type": "application/json"}, body: JSON.stringify(body) })
    .then(async (res) => {
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buf = "";
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buf += decoder.decode(value, { stream: true });
        const lines = buf.split("\n");
        buf = lines.pop();
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const evt = JSON.parse(line);
            onChunk?.(evt);
            if (evt.done) onDone?.(evt);
          } catch (e) { /* ignore */ }
        }
      }
      if (buf.trim()) {
        try {
          const evt = JSON.parse(buf);
          onChunk?.(evt);
          if (evt.done) onDone?.(evt);
        } catch {}
      }
    });
}

document.getElementById("ask").onclick = () => {
  const user = document.getElementById("user").value.trim();
  if (!user) return;
  const answer = document.getElementById("answer");
  const status = document.getElementById("status");
  answer.innerHTML = "";
  rawAnswerText = "";
  savedSelections = [];
  activeSelectionId = null;
  selectionCounter = 0;
  status.textContent = "Streaming...";
  lastMessageId = null;
  originalMessageId = null;
  
  document.getElementById("saveSelection").disabled = true;
  document.getElementById("savedSelections").style.display = "none";
  document.getElementById("chatContainer").style.display = "none";
  document.getElementById("mainChatContainer").style.display = "none";
  document.getElementById("focused").innerHTML = "";
  document.getElementById("chatMessages").innerHTML = "";
  document.getElementById("mainChatMessages").innerHTML = "";
  mainConversations = [];

  sseFetch(`${API}/generate`, { user, system: "You are a concise assistant. Be accurate." },
    (evt) => {
      if (evt.piece) {
        rawAnswerText += evt.piece;
        answer.innerHTML = marked.parse(rawAnswerText);
      }
      if (evt.message_id) {
        lastMessageId = evt.message_id;
      }
    },
    (evt) => {
      status.textContent = "Done. Message ID: " + evt.message_id;
      lastMessageId = evt.message_id;
      originalMessageId = evt.message_id; // Track original answer message ID
      // Show main conversation interface
      document.getElementById("mainChatContainer").style.display = "block";
      renderMainConversations();
      // Restore highlights only after streaming is complete
      if (savedSelections.length > 0) {
        restoreHighlights();
      }
    }
  );
};

function getSelectionByteOffsets(container, range) {
  if (!range) {
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    range = sel.getRangeAt(0);
  }
  
  if (!container.contains(range.commonAncestorContainer)) return null;
  const selectedText = range.toString();
  if (!selectedText || selectedText.trim().length === 0) return null;

  const pre = document.createRange();
  pre.setStart(container, 0); 
  pre.setEnd(range.startContainer, range.startOffset);
  const textBeforeSelection = pre.toString();
  
  const containerPlainText = container.textContent;
  const beforePlainTextLength = textBeforeSelection.length;
  const selectedPlainTextLength = selectedText.length;
  
  const textLengthRatio = containerPlainText.length > 0 
    ? rawAnswerText.length / containerPlainText.length 
    : 1;
  
  let startPos = Math.floor(beforePlainTextLength * textLengthRatio);
  let endPos = startPos + Math.floor(selectedPlainTextLength * textLengthRatio);
  
  const normalizedSelected = selectedText.trim().replace(/\s+/g, ' ');
  if (normalizedSelected.length > 0) {
    const searchWindow = 500;
    const searchStart = Math.max(0, startPos - searchWindow);
    const searchEnd = Math.min(rawAnswerText.length, endPos + searchWindow);
    const searchText = rawAnswerText.substring(searchStart, searchEnd);
    const cleanSearchText = searchText.replace(/[*_`~\[\]()#\n\r]/g, ' ').replace(/\s+/g, ' ');
    const matchIndex = cleanSearchText.indexOf(normalizedSelected);
    
    if (matchIndex >= 0) {
      let charCount = 0;
      let actualStart = searchStart;
      
      for (let i = 0; i < searchText.length && charCount < matchIndex; i++) {
        const char = searchText[i];
        if (!'*_`~[]()#\n\r'.includes(char)) {
          charCount++;
        }
        actualStart = searchStart + i + 1;
      }
      
      startPos = actualStart;
      let endCharCount = 0;
      let actualEnd = startPos;
      
      for (let i = actualStart - searchStart; i < searchText.length && endCharCount < normalizedSelected.length; i++) {
        const char = searchText[i];
        if (!'*_`~[]()#\n\r'.includes(char)) {
          endCharCount++;
        }
        actualEnd = searchStart + i + 1;
        if (endCharCount >= normalizedSelected.length) break;
      }
      
      endPos = actualEnd;
    }
  }
  
  startPos = Math.max(0, Math.min(startPos, rawAnswerText.length));
  endPos = Math.max(startPos, Math.min(endPos, rawAnswerText.length));
  
  const enc = new TextEncoder();
  const startBytes = enc.encode(rawAnswerText.substring(0, startPos)).length;
  const endBytes = enc.encode(rawAnswerText.substring(0, endPos)).length;
  
  return { start: startBytes, end: endBytes, text: selectedText, range: range.cloneRange() };
}

// Track selection changes
let currentSelection = null;
document.addEventListener("selectionchange", () => {
  const answer = document.getElementById("answer");
  const sel = window.getSelection();
  const saveBtn = document.getElementById("saveSelection");
  
  if (sel.rangeCount > 0) {
    const range = sel.getRangeAt(0);
    if (answer.contains(range.commonAncestorContainer) && !range.collapsed) {
      currentSelection = range;
      saveBtn.disabled = false;
    } else {
      saveBtn.disabled = true;
      currentSelection = null;
    }
  } else {
    saveBtn.disabled = true;
    currentSelection = null;
  }
});

// Save selection
document.getElementById("saveSelection").onclick = () => {
  if (!currentSelection || !lastMessageId) return;
  const answer = document.getElementById("answer");
  const off = getSelectionByteOffsets(answer, currentSelection);
  if (!off || off.start === off.end) return;

  const id = `sel_${selectionCounter++}`;
  const name = `Selection ${selectionCounter}`;
  const selection = {
    id,
    name,
    start: off.start,
    end: off.end,
    text: off.text.substring(0, 100) + (off.text.length > 100 ? "..." : ""),
    fullText: off.text,
    range: off.range,
    conversations: [], // Array of {question, answer, message_id}
    lastMessageId: null // Track the last message_id for continuing
  };

  savedSelections.push(selection);
  highlightSelection(selection);
  renderSelections();
  updateSaveButton();
  
  // Clear current selection
  window.getSelection().removeAllRanges();
  document.getElementById("saveSelection").disabled = true;
};

function highlightSelection(selection) {
  const answer = document.getElementById("answer");
  const walker = document.createTreeWalker(
    answer,
    NodeFilter.SHOW_TEXT,
    null
  );
  
  let node;
  let charCount = 0;
  let startNode = null, endNode = null;
  let startOffset = 0, endOffset = 0;
  
  // Find the text nodes containing the selection
  const range = selection.range;
  if (!range) return;
  
  startNode = range.startContainer;
  endNode = range.endContainer;
  startOffset = range.startOffset;
  endOffset = range.endOffset;
  
  // Wrap the selected text in a highlight span
  try {
    const highlight = document.createElement("span");
    highlight.className = "highlight";
    highlight.dataset.selectionId = selection.id;
    highlight.title = selection.name;
    highlight.style.cursor = "pointer";
    let clickStart = null;
    highlight.onmousedown = (e) => {
      clickStart = { x: e.clientX, y: e.clientY, time: Date.now() };
    };
    highlight.onmouseup = (e) => {
      if (clickStart) {
        const moved = Math.abs(e.clientX - clickStart.x) > 5 || Math.abs(e.clientY - clickStart.y) > 5;
        const timeDiff = Date.now() - clickStart.time;
        // Only activate if it's a quick click (not a drag) and no text is selected
        if (!moved && timeDiff < 300 && window.getSelection().toString().length === 0) {
          e.preventDefault();
          e.stopPropagation();
          activateSelection(selection.id);
        }
        clickStart = null;
      }
    };
    
    range.surroundContents(highlight);
    
    // Update the saved range reference
    selection.range = highlight;
  } catch (e) {
    // If surroundContents fails (e.g., selection crosses node boundaries), 
    // we'll handle it differently
    console.warn("Could not wrap selection:", e);
  }
}

function restoreHighlights() {
  // Re-highlight saved selections after re-rendering
  savedSelections.forEach(sel => {
    // We need to find the text again in the newly rendered content
    // This is a simplified approach - in production you'd want more robust matching
    const answer = document.getElementById("answer");
    const textNodes = getTextNodes(answer);
    let charCount = 0;
    let found = false;
    
    for (const node of textNodes) {
      const nodeText = node.textContent;
      const nodeLength = nodeText.length;
      const selStart = sel.start;
      const selEnd = sel.end;
      
      // Try to find the selection text in the rendered content
      const index = nodeText.indexOf(sel.fullText.substring(0, 50));
      if (index >= 0) {
        const range = document.createRange();
        range.setStart(node, index);
        range.setEnd(node, Math.min(index + sel.fullText.length, nodeLength));
        
        const highlight = document.createElement("span");
        highlight.className = "highlight";
        highlight.dataset.selectionId = sel.id;
        highlight.title = sel.name;
        highlight.style.cursor = "pointer";
        let clickStart = null;
        highlight.onmousedown = (e) => {
          clickStart = { x: e.clientX, y: e.clientY, time: Date.now() };
        };
        highlight.onmouseup = (e) => {
          if (clickStart) {
            const moved = Math.abs(e.clientX - clickStart.x) > 5 || Math.abs(e.clientY - clickStart.y) > 5;
            const timeDiff = Date.now() - clickStart.time;
            if (!moved && timeDiff < 300 && window.getSelection().toString().length === 0) {
              e.preventDefault();
              e.stopPropagation();
              activateSelection(sel.id);
            }
            clickStart = null;
          }
        };
        
        try {
          range.surroundContents(highlight);
          sel.range = highlight;
          found = true;
          break;
        } catch (e) {}
      }
    }
  });
}

function getTextNodes(node) {
  const textNodes = [];
  const walker = document.createTreeWalker(
    node,
    NodeFilter.SHOW_TEXT,
    null
  );
  
  let n;
  while (n = walker.nextNode()) {
    textNodes.push(n);
  }
  return textNodes;
}

function renderSelections() {
  const container = document.getElementById("savedSelections");
  const list = document.getElementById("selectionsList");
  
  if (savedSelections.length === 0) {
    container.style.display = "none";
    return;
  }
  
  container.style.display = "block";
  list.innerHTML = "";
  
  savedSelections.forEach(sel => {
    const item = document.createElement("div");
    item.className = "selection-item" + (activeSelectionId === sel.id ? " active" : "");
    item.innerHTML = `
      <div class="selection-header">
        <span class="selection-name">${sel.name}</span>
        <div class="selection-actions">
          <button class="btn-small chat" onclick="activateSelection('${sel.id}')">Chat</button>
          <button class="btn-small delete" onclick="deleteSelection('${sel.id}')">Delete</button>
        </div>
      </div>
      <div class="selection-text">${sel.text}</div>
    `;
    list.appendChild(item);
  });
}

window.activateSelection = (id) => {
  const selection = savedSelections.find(s => s.id === id);
  if (!selection) return;
  
  activeSelectionId = id;
  document.getElementById("activeSelectionName").textContent = selection.name;
  document.getElementById("chatContainer").style.display = "block";
  // Hide main chat when selection chat is active (but keep it ready to come back)
  document.getElementById("mainChatContainer").style.display = "none";
  
  // Render existing conversations
  renderConversations(selection);
  
  // Update highlight visuals
  document.querySelectorAll(".highlight").forEach(h => {
    h.classList.remove("active");
    if (h.dataset.selectionId === id) h.classList.add("active");
  });
  
  renderSelections();
  
  // Focus on input
  document.getElementById("followup").focus();
};

// Function to show main chat again
window.showMainChat = () => {
  activeSelectionId = null;
  document.getElementById("chatContainer").style.display = "none";
  // Show main chat if we have an original message
  if (originalMessageId) {
    document.getElementById("mainChatContainer").style.display = "block";
    renderMainConversations();
    document.getElementById("mainFollowup").focus();
  }
};

window.deleteSelection = (id) => {
  if (confirm("Delete this selection?")) {
    const index = savedSelections.findIndex(s => s.id === id);
    if (index >= 0) {
      // Remove highlight
      const highlight = document.querySelector(`.highlight[data-selection-id="${id}"]`);
      if (highlight) {
        const parent = highlight.parentNode;
        parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
        parent.normalize();
      }
      
      savedSelections.splice(index, 1);
      
      if (activeSelectionId === id) {
        activeSelectionId = null;
        document.getElementById("chatContainer").style.display = "none";
        // Show main chat again if we have an original message
        if (originalMessageId) {
          document.getElementById("mainChatContainer").style.display = "block";
          renderMainConversations();
        }
      }
      
      renderSelections();
      updateSaveButton();
    }
  }
};

function renderConversations(selection) {
  const container = document.getElementById("chatMessages");
  container.innerHTML = "";
  
  selection.conversations.forEach(conv => {
    // User message
    const userMsg = document.createElement("div");
    userMsg.className = "chat-message user";
    userMsg.textContent = conv.question;
    container.appendChild(userMsg);
    
    // Assistant message
    const assistantMsg = document.createElement("div");
    assistantMsg.className = "chat-message assistant";
    assistantMsg.innerHTML = marked.parse(conv.answer || "[Loading...]");
    container.appendChild(assistantMsg);
  });
  
  container.scrollTop = container.scrollHeight;
}

document.getElementById("sendFollowup").onclick = () => {
  const followup = document.getElementById("followup").value.trim();
  if (!followup || !originalMessageId || !activeSelectionId) return;
  
  const selection = savedSelections.find(s => s.id === activeSelectionId);
  if (!selection) return;
  
  // Add user message to conversation
  selection.conversations.push({ question: followup, answer: "", message_id: null });
  renderConversations(selection);
  
  // Clear input and disable button
  document.getElementById("followup").value = "";
  const sendBtn = document.getElementById("sendFollowup");
  sendBtn.disabled = true;
  
  const focused = document.getElementById("focused");
  focused.innerHTML = "<em>Thinking...</em>";
  
  // Use /focus for first message, /continue for subsequent ones
  const isFirstMessage = selection.conversations.length === 1;
  
  if (isFirstMessage) {
    // First follow-up: use /focus endpoint with original message ID
    sseFetch(`${API}/focus`, {
        message_id: originalMessageId,
        char_start: selection.start,
        char_end: selection.end,
        followup,
        system: "Focus only on the provided excerpt. Do not use any other context."
      },
      (evt) => {
        if (evt.piece) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.answer = (lastConv.answer || "") + evt.piece;
          focused.innerHTML = marked.parse(lastConv.answer);
        }
        if (evt.message_id) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.message_id = evt.message_id;
          selection.lastMessageId = evt.message_id;
        }
      },
      (evt) => {
        sendBtn.disabled = false;
        if (evt && evt.message_id) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.message_id = evt.message_id;
          selection.lastMessageId = evt.message_id;
        }
        renderConversations(selection);
      }
    );
  } else {
    // Subsequent follow-ups: use /continue endpoint
    const historyToUse = selection.lastMessageId ? [selection.lastMessageId] : [];
    sseFetch(`${API}/continue`, {
        user: followup,
        history: historyToUse,
        system: "Focus only on the provided excerpt. Do not use any other context."
      },
      (evt) => {
        if (evt.piece) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.answer = (lastConv.answer || "") + evt.piece;
          focused.innerHTML = marked.parse(lastConv.answer);
        }
        if (evt.message_id) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.message_id = evt.message_id;
          selection.lastMessageId = evt.message_id;
        }
      },
      (evt) => {
        sendBtn.disabled = false;
        if (evt && evt.message_id) {
          const lastConv = selection.conversations[selection.conversations.length - 1];
          lastConv.message_id = evt.message_id;
          selection.lastMessageId = evt.message_id;
        }
        renderConversations(selection);
      }
    );
  }
};

// Allow Enter to send (Shift+Enter for new line)
document.getElementById("followup").addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    document.getElementById("sendFollowup").click();
  }
});

function renderMainConversations() {
  const container = document.getElementById("mainChatMessages");
  container.innerHTML = "";
  
  mainConversations.forEach(conv => {
    // User message
    const userMsg = document.createElement("div");
    userMsg.className = "chat-message user";
    userMsg.textContent = conv.question;
    container.appendChild(userMsg);
    
    // Assistant message
    const assistantMsg = document.createElement("div");
    assistantMsg.className = "chat-message assistant";
    assistantMsg.innerHTML = marked.parse(conv.answer || "[Loading...]");
    container.appendChild(assistantMsg);
  });
  
  container.scrollTop = container.scrollHeight;
}

document.getElementById("sendMainFollowup").onclick = () => {
  const followup = document.getElementById("mainFollowup").value.trim();
  if (!followup || !originalMessageId) return;
  
  // Add user message to conversation
  mainConversations.push({ question: followup, answer: "", message_id: null });
  renderMainConversations();
  
  // Clear input and disable button
  document.getElementById("mainFollowup").value = "";
  const sendBtn = document.getElementById("sendMainFollowup");
  sendBtn.disabled = true;
  
  const focused = document.getElementById("focused");
  focused.innerHTML = "<em>Thinking...</em>";
  
  // Build history array: if we have previous main conversations, use the last message_id,
  // otherwise use the original message_id
  const history = [];
  if (mainConversations.length > 1) {
    // Find the last conversation that has a message_id
    for (let i = mainConversations.length - 2; i >= 0; i--) {
      if (mainConversations[i].message_id) {
        history.push(mainConversations[i].message_id);
        break;
      }
    }
    // If no previous message_id found, use original
    if (history.length === 0) {
      history.push(originalMessageId);
    }
  } else {
    // First follow-up: use original message_id
    history.push(originalMessageId);
  }
  
  sseFetch(`${API}/continue`, {
      user: followup,
      history: history,
      system: "You are a concise assistant. Be accurate."
    },
    (evt) => {
      if (evt.piece) {
        const lastConv = mainConversations[mainConversations.length - 1];
        lastConv.answer = (lastConv.answer || "") + evt.piece;
        focused.innerHTML = marked.parse(lastConv.answer);
      }
      if (evt.message_id) {
        // Update to the new message ID for next continuation
        const lastConv = mainConversations[mainConversations.length - 1];
        lastConv.message_id = evt.message_id;
        // Don't update originalMessageId - keep it separate
      }
    },
    (evt) => {
      sendBtn.disabled = false;
      if (evt && evt.message_id) {
        const lastConv = mainConversations[mainConversations.length - 1];
        lastConv.message_id = evt.message_id;
      }
      renderMainConversations();
    }
  );
};

// Allow Enter to send (Shift+Enter for new line) for main followup
document.getElementById("mainFollowup").addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    document.getElementById("sendMainFollowup").click();
  }
});

document.getElementById("clearHighlights").onclick = () => {
  if (confirm("Clear all saved selections?")) {
    savedSelections.forEach(sel => {
      const highlight = document.querySelector(`.highlight[data-selection-id="${sel.id}"]`);
      if (highlight) {
        const parent = highlight.parentNode;
        parent.replaceChild(document.createTextNode(highlight.textContent), highlight);
        parent.normalize();
      }
    });
    
    savedSelections = [];
    activeSelectionId = null;
    document.getElementById("chatContainer").style.display = "none";
    renderSelections();
    updateSaveButton();
  }
};

function updateSaveButton() {
  // Button state is managed by selectionchange event
}
</script>
</body>
</html>
